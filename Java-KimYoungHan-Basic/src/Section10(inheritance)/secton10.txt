상속 관계
상속은 객체 지향 프로그래밍의 핵심 요소 중 하나로, 기존 클래스의 필드와 메서드를 새로운 클래스에서 재사용하게 해
준다. 이름 그대로 기존 클래스의 속성과 기능을 그대로 물려받는 것이다. 상속을 사용하려면 `extends` 키워드를 사용
하면 된다. 그리고 `extends` **대상은 하나만 선택**할 수 있다.
**용어 정리**
**부모 클래스 (슈퍼 클래스)**: 상속을 통해 자신의 필드와 메서드를 다른 클래스에 제공하는 클래스
**자식 클래스 (서브 클래스)**: 부모 클래스로부터 필드와 메서드를 상속받는 클래스
**주의!**
**지금부터 코드를 작성할 때 기존 코드를 유지하기 위해, 새로운 패키지에 기존 코드를 옮겨가면서 코드를 작성할 것이다.
클래스의 이름이 같기 때문에 패키지 명과 import 사용에 주의해야 한다.**

상속기능을 받았을 때 본인한테 없으면 위로 올라가서 확인
java 에서는 다중 상속을 지원하지 않는다


`new ElectricCar()` 를 호출하면 `ElectricCar` 뿐만 아니라 상속 관계에 있는 `Car` 까지 함께 포함해서 인스턴
스를 생성한다. 참조값은 `x001`
로 하나이지만 실제로 그 안에서는 `Car` , `ElectricCar` 라는 두가지 클래스 정보가
공존하는 것이다.

즉 내부에서는 부모와 자식이 모두 생성되고 공간도 구분된다
호출하는 변수의 타입(클래스) 을 기준으로 찾기 시작
본인 타입에 없으면 부뫁타입에서 찾기
부모에서도 해당 기능을 찾지 못하면 더 사우이 부모에서 필요한 기능을 찾아봄

부모에게서 상속 받은 기능을 자식이 재정의 하는 것을 메서드 오버라이딩



에노테이션
    @Override
    public void move() {
        System.out.println("전기차를 빠르게 이동합니다.");
    }
옵션이지만 붙혀주는 것이 좋음
실수로 오버라이딩을 못하는 경우를 방지해준다

**접근 제어자**: 오버라이딩 메서드의 접근 제어자는 상위 클래스의 메서드보다 더 제한적이어서는 안된다. 예를 들
어, 상위 클래스의 메서드가 `protected`
로 선언되어 있으면 하위 클래스에서 이를 `public` 또는
`protected`
로 오버라이드할 수 있지만, `private` 또는 `default`
로 오버라이드 할 수 없다.

protected
패키지가 달라도 상속 관계의 호출을 허용한다

객체 내부에서는 자식과
부모가 구분되어 있기 때문이다. 결국 자식 타입에서 부모 타입의 기능을 호출할 때, 부모 입장에서 보면 외부에서 호출
한 것과 같다.

super 부모 참조 : 자식클래스 에서 value 와 hello() 를 호출하고 싶다면 super 키워드 사용
    this.hello();
    super.hello();

super 생성자
    상속 관계의 인스턴스를 생성하면 결국 메모리 내부에서는 자식과 부모 클래스가 각각 다 만들어진다.
    Child 를 만들면 부모인 Parent 까지 만들어지는 것.
    따라서 각각의 생성자도 모두 호출되어야 한다.

    즉, 상속 관계를 사용하면 자식 클래스의 생성자에서 부모 클래스의 생성자를 반드시 호출해야 한다.
    상속 관계에서 부모의 생성자를 호출할 때는 super 를 사용


package super1;

public class ClassC extends ClassB {
    public ClassC() {
        super(10, 20); // 생성자 하나도 없으면 기본 생성자가 자동 생성
        // 생성자를 하나롣 정의해버리면 기본 생성자는 자바에서 만들지 않음
        // 기본 생성자인 경우에만 super 생략 가능
        // 매개변수가 있는 생성자인 경우엔 명시
        System.out.println("ClassC constructor");
    }
}

상속 관계의 생성자 호출은 결과적으로 부모에서 자식 순서로 실행된다. 따라서 부모의 데이터를 먼저 초기화하고
그 다음 자식의 데이터를 초기화한다



